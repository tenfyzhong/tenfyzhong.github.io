<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[psftp,pscp自动与服务器进行sftp,scp通信python库]]></title>
    <url>%2F2017%2F09%2F04%2Fpsftp-and-pscp%2F</url>
    <content type="text"><![CDATA[懒是程序猿的本性。一切重复的东西，程序猿都可以写成脚本来让它自己运行。很多时候程 序猿要写脚本去连到服务器上去执行些命令，其中还包含上传文件到服务器或者从服务器上 下载文件下来。 Python很适合用于做后台和运维等。于是乎，很多自动化脚本都用了python来写。对于要进 交互的自动化脚本，python有一个很强大的包pexpect。它可以捕捉输出，匹配输出之后，发 送交互内容过去。比如ssh连接到某台服务器，执行一系列命令后退出。那么这时候，ssh连 进行输入密码，连上去之后，输入一条命令，等待执行完，输入另一条命令，等待执行完，如 此重复。 但是，捕捉输出是非常烦的事情，比如ssh的连接，有可能会提醒输入密码，也有可能会提醒 你把服务器地址保存到known_hosts里面等。每次写脚本时都要做这些重复的工作，于是程序 猿又发挥了他懒的天性，于是乎又有了pxssh，基于pexpect，完成了登录，捕捉命令行的 PROMPT捕捉等。 对于要与服务器进行文件上传下载，要用到scp或者sftp了。对于这两个程序，跟ssh是同一 系统的程序，命令过程基本完全一致。但是却没有这两个程序的封装。于是乎，就有了psftp 和pscp。 pxssh是pexpect库自带的，而psftp和pscp是我自己写的，为了是跟pxssh一样的目的，不要 让那些登录的烦着猿。 pscp首先简介简单的pscp。pscp基本scp程序，scp非常简单，类似于cp，它把文件copy到服务器， 或者从服务器copy到本地，然后它就结束了。所以pscp命令也非常简单，它只要完成自动 登录，然后捕捉结束就行了。所以它的核心只有两个函数和一个构造函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243def __init__( self, timeout=60, maxread=100, searchwindowsize=None, logfile=None, cwd=None, env=None, ignore_sighup=True, echo=True, options=&#123;&#125;, encoding=None, codec_errors='strict')# 上传到服务器def to_server( self, src, dst, server, username, password='', terminal_type='ansi', timeout=10, port=None, ssh_key=None, quiet=True, check_local_ip=True)# 从服务器下载def from_server( self, src, dst, server, username, password='', terminal_type='ansi', timeout=10, port=None, ssh_key=None, quiet=True, check_local_ip=True) 大部分参数都是默认参数来的。下面是一个例子： 123456789101112import pscpimport getpasss = pscp.pscp()src = raw_input('src: ')dst = raw_input('dst: ')hostname = raw_input('hostname: ')username = raw_input('username: ')password = getpass.getpass('password: ')try: s.to_server(src, dst, hostname, username, password)except: pass psftppsftp比pscp多了一些命令，可以进行交互，在*nix上可以用man sftp可以看到它有的命令。 对于写脚本进行自动化，主要用到以下的一些命令: get 下载到本地 put 上传到服务器 cd cd到服务器上的目录 lcd cd本地的目录 这个定义了命令一样名字的函数，并进行了捕捉PROMPT，所以只有简单的像命令一样使用就 可以了。比如： 12345678910111213141516import psftpimport getpasstry: s = psftp.psftp() hostname = raw_input('hostname: ') username = raw_input('username: ') password = getpass.getpass('password: ') s.login(hostname, username, password) print s.pwd() print s.lpwd() print s.lls() print s.ls() s.put('./hello.txt') print s.ls()except: pass 具体文档可以clone repo下来用浏览器打开docs下的文档文件。]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim函数feedkeys使用说明]]></title>
    <url>%2F2017%2F09%2F02%2Fvim-feedkeys%2F</url>
    <content type="text"><![CDATA[背景很多人在使用feedkeys函数的时候会得取不预期的输出，怎么折腾也搞不明白为什么会得到 这样的结果。这篇文章来给大家解疑一下。 feedkeys函数文档1234567891011121314151617181920212223242526272829303132333435feedkeys(&#123;string&#125; [, &#123;mode&#125;]) *feedkeys()* Characters in &#123;string&#125; are queued for processing as if they come from a mapping or were typed by the user. By default the string is added to the end of the typeahead buffer, thus if a mapping is still being executed the characters come after them. Use the &apos;i&apos; flag to insert before other characters, they will be executed next, before any characters from a mapping. The function does not wait for processing of keys contained in &#123;string&#125;. To include special keys into &#123;string&#125;, use double-quotes and &quot;\...&quot; notation |expr-quote|. For example, feedkeys(&quot;\&lt;CR&gt;&quot;) simulates pressing of the &lt;Enter&gt; key. But feedkeys(&apos;\&lt;CR&gt;&apos;) pushes 5 characters. If &#123;mode&#125; is absent, keys are remapped. &#123;mode&#125; is a String, which can contain these character flags: &apos;m&apos; Remap keys. This is default. &apos;n&apos; Do not remap keys. &apos;t&apos; Handle keys as if typed; otherwise they are handled as if coming from a mapping. This matters for undo, opening folds, etc. &apos;i&apos; Insert the string instead of appending (see above). &apos;x&apos; Execute commands until typeahead is empty. This is similar to using &quot;:normal!&quot;. You can call feedkeys() several times without &apos;x&apos; and then one time with &apos;x&apos; (possibly with an empty &#123;string&#125;) to execute all the typeahead. Note that when Vim ends in Insert mode it will behave as if &lt;Esc&gt; is typed, to avoid getting stuck, waiting for a character to be typed before the script continues. &apos;!&apos; When used with &apos;x&apos; will not end Insert mode. Can be used in a test when a timer is set to exit Insert mode a little later. Useful for testing CursorHoldI. Return value is always 0. 说明文档说了这个函数的使用方式，但是对于大部分人，只理解了一部分，帮而会产生很多 不解的行为。这个函数会把参数中的{string}当前是用户输入的。默认的，它会把string 的内容放到预输入的buffer(下面直接引用说明文档中的typeahead buffer)中。对于不解行为，主要都是由这个typeahead buffer产生了。这个typeahead buffer并不是我 们所熟悉的vim与文档内容关联的buffer，下面会对它进行详细的说明。很多人认为，只要 一调用feedkeys，它就立刻产生作用。例如下面这个例子：1234function! Test1() call feedkeys(&quot;a123\&lt;ESC&gt;&quot;, &quot;n&quot;) call feedkeys(&quot;a456\&lt;ESC&gt;&quot;, &quot;n&quot;)endfunction 这个例子很明显，调用Test1后，会在当前的buffer(这个是大家所熟悉的与文档内容相关 的buffer，下面对于只出现buffer的都说的是这个buffer，而对于预输入buffer会使用 typeahead buffer)。 我们再来看一个例子：12345function! Test2() normal! a123 call feedkeys(&quot;a456\&lt;ESC&gt;&quot;, &quot;n&quot;) normal! a789endfunction 大家先猜想一下这个例子的输出。很多人理所当然地以为这个会输出123456789。然而， 它输出的却是123789456。456被移到后面去了。为什么会这样？下面来说一下typeahead buffer。 typeahead buffervim维护了一个typeahead buffer来用存放用户预输入的内容。然后vim从typeahead buffer 中取数据当成是用户输入数据进行处理。在用户没有输入，也没有函数执行的时候，这个时 候就会执行typeahead buffer里面的内容了。那么这个typeahead buffer的内容是怎么插进去的呢？ normal命令 @r寄存器 abbreviate的内容 feedkeys()函数 所有插入到typeahead buffer的内容都调用了这个函数来进行插入(neovim源码) 1234567891011121314151617181920/* * insert a string in position 'offset' in the typeahead buffer (for "@r" * and ":normal" command, vgetorpeek() and check_termcode()) * * If noremap is REMAP_YES, new string can be mapped again. * If noremap is REMAP_NONE, new string cannot be mapped again. * If noremap is REMAP_SKIP, fist char of new string cannot be mapped again, * but abbreviations are allowed. * If noremap is REMAP_SCRIPT, new string cannot be mapped again, except for * script-local mappings. * If noremap is &gt; 0, that many characters of the new string cannot be mapped. * * If nottyped is TRUE, the string does not return KeyTyped (don't use when * offset is non-zero!). * * If silent is true, cmd_silent is set when the characters are obtained. * * return FAIL for failure, OK otherwise */int ins_typebuf(char_u *str, int noremap, int offset, int nottyped, bool silent) 将str插入到typeahead buffer中，插入的位置是offset。noremap由feedkeys中的n选项 控制。nottyped由feedkeys中的t选项控制。 以normal的方式说明typeahead buffer插入内容去nvim中找取normal的源码12345678910111213141516171819202122232425262728/** Execute normal mode command "cmd".* "remap" can be REMAP_NONE or REMAP_YES.*/void exec_normal_cmd(char_u *cmd, int remap, bool silent)&#123; // Stuff the argument into the typeahead buffer. ins_typebuf(cmd, remap, 0, true, silent); exec_normal(false);&#125;/// Execute normal_cmd() until there is no typeahead left.////// @param was_typed whether or not something was typedvoid exec_normal(bool was_typed)&#123; oparg_T oa; clear_oparg(&amp;oa); finish_op = false; while ((!stuff_empty() || ((was_typed || !typebuf_typed()) &amp;&amp; typebuf.tb_len &gt; 0)) &amp;&amp; !got_int) &#123; update_topline_cursor(); normal_cmd(&amp;oa, true); // execute a Normal mode cmd &#125;&#125; 对于normal插入的内容，会插入到typeahead buffer的开头，并会立马就执行，一直到非 normal或者mapping。所以对于Test2的例子，它遇到normal会插入到typeahead buffer的开头，然后执行。 然后feedkeys插入新的内容到typeahead buffer，这时typebuf_typed是TRUE的。 然后又插入normal的789，当9插入完后，typebuf_typed又变成TRUE了。所以feedkeys 的内容会一直等到函数执行完等待用户输入内容的时候，才会进行执行。所以最后就出现了 123789456的结果了。 feedkeys的选项i的作用默认情况下，feedkeys所内容加到typeahead buffer的后面。当加上i这个选项的时候， 它会传0给ins_typebuf的offset字段。这时候就插在了开头。来个例子看一下效果。12345function! Test3() call feedkeys(&quot;a123\&lt;ESC&gt;&quot;, &quot;n&quot;) call feedkeys(&quot;a456\&lt;ESC&gt;&quot;, &quot;n&quot;) normal a789endfunction 这个例子，没有i选项，毫无疑问这个的输出是789123456。下面这个例子加了i选项：12345function! Test4() call feedkeys(&quot;a123\&lt;ESC&gt;&quot;, &quot;n&quot;) call feedkeys(&quot;a456\&lt;ESC&gt;&quot;, &quot;in&quot;) normal a789endfunction 这个的456插入到了123前面了。所以这个的输出是789456123]]></content>
  </entry>
  <entry>
    <title><![CDATA[prometheus丢数据调试与处理]]></title>
    <url>%2F2017%2F09%2F02%2Fprometheus-lost-data%2F</url>
    <content type="text"><![CDATA[背景：influxdb数据旁路一份到prometheus后，prometheus的图有时延时很大，主要是在业务忙的 时候，闲的时候是可以处理到数据的。而influxdb的数据是可以正常显示的。而且这时牛逼 的google并帮不了忙，各种关键字去搜索都找不到相关的问题。 架构 调试过程 先去prometheus的web控制台看图。初看这个图感觉是没有问题的，数据是连续的。 仔细看，其实直线那段是没有数据有。用grafana配到同一个prometheus来看一下grafana的 图长这样 在grafana是可以明显看到中间是丢了一段时间的。而且prometheus的图却是连续的。最开始我没有看出来。 把生产环境的docker部到自己的电脑，看控制台是没有问题的。所以猜想是生产环境的 数据量过大，prometheus没处理过来引起的。 上去生产环境抓包， 先找一下prometheus和influxdb_exporter的ip。 1docker exec -it prometheus ip addr show 输出如下： prometheus用了eth0端口，ip:172.17.0.102 同样找出influxdb_exporter的ip:172.17.0.99 我们只抓这两台机器的包，免得其他的干扰： 1tcpdump -i docker0 host 172.17.0.102 and 172.17.0.99 在13:32:28.162的时候prometheus发起握手，完了之后，发请求到influxdb_exporter拉数据在13:32:32.112的时候influxdb_exporter发了数据包。然后prometheus接着就回了一下 rst的包了。后面influxdb_exporter应该是还没收到prometheus的rst包，继续发第二段包。 所以这个包prometheus是没有收到的。 找到prometheus的配置： scrape_configs: job_name: ‘prometheus’scrape_interval: 5sstatic_configs: targets: “influxdb_exporter:9122” 配置了5s去influxdb_exporter抓一次数据。而prometheus发rst包的时候，差不多在4s的时 间隔上。prometheus的5s配置包括了收包前后的处理和收包的过程，在13:32:32.112的时候 就回rst，以免雪崩。把配置改成10s，重新拉起服务。可以看数据正常了。]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>prometheus</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang直接操作共享内存]]></title>
    <url>%2F2017%2F09%2F02%2Fgolang-share-memory%2F</url>
    <content type="text"><![CDATA[Golang不使用cgo，直接操作共享内存。 前言故事起源于要搭一个高性能的日志中心。当然使用了elk这一套。但是，对于logstash来说， 它主要使用的是文件日志的方式了捕捉log。而写文件日志的话会非常慢。对于实时日志要 处理滚动的日志更是这样，每次检查是否需要流动日志，然后打开日志，然后写入，然后 关闭，当然这中间可以优化。这一切都是那么慢，发起了n个系统调用，硬盘寻道等。这时 候想到了用共享内存来通信。 共享内存的基本知识要使用共享内存要执行以下几步： 发起一个系统调用，让系统帮你生产一块内存，或者取得一块已经存在的内存来使用。 把内存attach到当前进程，让当前进程可以使用。大家都知道，我们在进程中访问的是 虚拟内存地址，系统会把它映射到物理内存中。如果没有这一步，第1步创建的内存就 不能在当前进程访问。 这时就可以对内存进程读写操作了。 进程结束的时候要把上面attach的内存给释放。 系统调用的基础知识什么是系统调用? 系统调用（英语：system call），又称为系统呼叫，指运行在使用者空间的程序向操作 系统内核请求需要更高权限运行的服务。系统调用提供用户程序与操作系统之间的接口。 以上引自维基百科。 对于每个系统调用，都一个编号。内核收到编号后，就根据编号去找到对应的内核函数函数 来执行。然后返回给应用程序。 系统调用是怎么发起的？以下以linux为例。 应用程序以系统调用号和对应的参数传给系统调用api 系统调用api将系统调用号存到eax中，然后发起0x80的中断号进行中断 内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用） 系统调用完成相应功能，将返回值存入 eax，返回到中断处理函数 中断处理函数返回到 API 中 API 将 eax 返回给应用程序 以上就完成了系统调用。 在golang中使用共享内存了解了系统调用之后，下面就开始使用了。第一步当然是去找golang有没有直接提供共享内 存的api了。几经折腾后，发现它并没有提供直接的api。而其他很多系统调用都提供了直接 的api。究其原因，我想应该是因为这句话吧： “不要通过共享内存来通信，而应该通过通信来共享内存” golang不提供使用共享内存来通信。所以直接不提供了，折腾死你们，让你们用不了。于是乎，google一下解决方案，都是通过cgo来调c语言来实现的。stackoverflow的答案也 都是这样。回来再来看一下golang的syscall的文档。它提供了 Syscall函数。声明如下： 1func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno) 很显示trap是中断号，a1, a2, a3是系统调用相关的参数。对于中断号，在文档中可以看到，所有的系统都已经定义了常量了。而我们要用到的系统调 用有：SYS_SHMGET: 创建或者取得共享内存。SYS_SHMAT: 将共享内存attach到当前进程空间。SYS_SHMDT: 将共享内存从当前进程中deattach。 具体这三个函数的使用，我们可以参考linux的shmget, shmat, shmdt函数。可以看 到这三个函数跟上面三个系统调用号的常量名字一样的。 以下是这三个函数的声明： 123int shmget(key_t key, size_t size, int shmflg); void *shmat(int shm_id, const void *shm_addr, int shmflg); int shmdt(const void *shmaddr); 以下简单介绍一下这三个函数，具体可以直接去linux上man对应的文档。 shmget函数key，这个参数的类型key_y其实只是一个数字类型。这个参数命名了这一块内存。不要 提供0值就行了，0值是private的，不能在进程间共享。size，提供了共享内存的大小。shmflg，权限标志，它的作用与open函数的mode参数一样。如果需要在内存不存在时创建 它，则需要指定IPC_CREAT。在golang的文档中可以看到，它并没定义IPC_CREATE的值。所以我们只能去找到它的值了。 在linux的man文档中，它也没有说明。于是乎，直接把linux的代码clone下来进行了grep (我用ag，速度非常快的文档查找工具)。从结果中找到了IPC_CREATE是一个宏，它的值定 义成了00001000。一个8进制的数字。低三位都是0，因为低三位是用来标志权限位的。 下面我们直接来发起这个系统调用看一下效果，把调用c的参数一一对应到a1, a2, a3中： 1shmid, _, err := syscall.Syscall(syscall.SYS_SHMGET, 2, 4, IpcCreate|0600) Syscall函数返回了两个值和一个error字段。而c的shmget只返回了一个int值，因为这 个函数把结果错误和结果都通过返回值来承载了，如果是小于0的，则是错误，这时对应到 go中应该是err的值，没有错误的时候，我们只需要一个返回值，第二个返回值会一直是0。 第一个返回值就是给shmat调用的第一个参数。 shmat函数shm_id, 这是shmget返回id，以标志了要attach的是这一块内存shm_addr，这个标志需要把它attach到的内存地址，通常填0，让系统去选择地址来attachshmflg，这个可以值SHM_RDONLY表示只读，其他值为可以读写，我们直接传0就好。 1shmaddr, _, err := syscall.Syscall(syscall.SYS_SHMAT, shmid, 0, 0) c函数返回了进程空间地址，这个调用也是只返回了一个值，所我们只接收第一个值。在c中， 如果调用失败，会返回-1。在go中，我们只要直接处理err的值就好了。 shmdt函数shmaddr, 这个参数表示deattach的地址值，是从shmat中返回的。 我们在go中直接用defer来调用就好了： 1defer syscall.Syscall(syscall.SYS_SHMDT, shmaddr, 0, 0) 以下是这个blog用到的代码，可以直接从gist里去下载： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// @file main.go// @brief// @author tenfyzhong// @email tenfyzhong@qq.com// @created 2017-06-26 17:54:34package mainimport ( "flag" "fmt" "os" "syscall" "time" "unsafe")const ( // IpcCreate create if key is nonexistent IpcCreate = 00001000)var mode = flag.Int("mode", 0, "0:write 1:read")func main() &#123; flag.Parse() shmid, _, err := syscall.Syscall(syscall.SYS_SHMGET, 2, 4, IpcCreate|0600) if err != 0 &#123; fmt.Printf("syscall error, err: %v\n", err) os.Exit(-1) &#125; fmt.Printf("shmid: %v\n", shmid) shmaddr, _, err := syscall.Syscall(syscall.SYS_SHMAT, shmid, 0, 0) if err != 0 &#123; fmt.Printf("syscall error, err: %v\n", err) os.Exit(-2) &#125; fmt.Printf("shmaddr: %v\n", shmaddr) defer syscall.Syscall(syscall.SYS_SHMDT, shmaddr, 0, 0) if *mode == 0 &#123; fmt.Println("write mode") i := 0 for &#123; fmt.Printf("%d\n", i) *(*int)(unsafe.Pointer(uintptr(shmaddr))) = i i++ time.Sleep(1 * time.Second) &#125; &#125; else &#123; fmt.Println("read mode") for &#123; fmt.Println(*(*int)(unsafe.Pointer(uintptr(shmaddr)))) time.Sleep(1 * time.Second) &#125; &#125;&#125; 运行一下这个代码块看一下结果： 用ipcs可以看到共享已经成功创建。 对于共享内存的操作，大家还可以看一下shmctl这个系统调用的使用。]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[complete_parameter]]></title>
    <url>%2F2017%2F09%2F02%2Fcomplete-parameter%2F</url>
    <content type="text"><![CDATA[YouCompleteMe给vim做补全非常方便，但是补全出函数后，却不会补全上参数。这是一个 辅助YouCompleteMe、deoplete、neocomplete补全插件进行补全参数的插件。 前言YouCompleteMe给vim做补全非常方便，但是补全出函数后，却不会补全上参数。这是一个 辅助YouCompleteMe、deoplete、neocomplete补全插件进行补全参数的插件。从此函数补 全完后，再也不用跳去看声明参数要怎么填了。插件链接：tenfyzhong/CompleteParameter.vim 只有补全引擎的vim注：以下所有的例子都以YouCompleteMe为例子，使用deoplete、neocomplete也是一样的。 并且以golang为例子，当然目前已经支持了多种语言，详细请看github上的README字不重要，看下图： ycm呼起了补全菜单，选中补全列表中的一项后，按左括号开始填参数。对于大的函数， 这时候就蒙圈了，忘了要填什么参数了。就只有跳到函数声明或者文档上去看参数，而且 经常是看了第一个，回来填好后，再去看第二个，如此循环。 参数补全闪亮登场继续看图： 还是ycm呼起了补全菜单，选中补全列表中的一项后，按左括号，形参的名字已经补全上来了， 并且这时使用选择模式选中了第一个参数，直接输入内容，当前选中的内容就会被删除， 而插入输入的内容。第一个参数填完后，按&lt;m-n&gt;(默认跳转到下一个参数的映射键)， 就跳到第二个参数，并且又进入了选择模式。修改完后，就可以继续按&lt;m-n&gt;跳到下一个 参数(如果没有下一个参数了，则会跳到右括号之后，并且进行插入模式)。当跳到下一个参数后发现上一个参数输错了，这时还可以通过&lt;m-p&gt;来跳回到上一个参数， 并且选择了它，又可以进行修改了。有时候调用函数，已经有了跟形参一样名字的变量了，这时候补全完之后，因为插入的形参 名字和变量名字一样，这时候就不用修改了。直接按&lt;m-n&gt;跳到下一个位置即可。 已经支持的语言(截止到2017年7月1日) c c++ golang python erlang javascript typescript rust]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工程makefile管理的一种比较合理的方案]]></title>
    <url>%2F2017%2F09%2F01%2Fproject-makefile%2F</url>
    <content type="text"><![CDATA[现状可以说makefile也是代码，都是命令的集合。代码臭味中最出名的算是重复代码了。而工程 中的makefile存在这样的情况。每新建一个目录，就将别的目录下的makefile拷过来，这个 makefile文件包含了进行编译的所有指令。 这篇文章将会让你的Makefile清晰明了。 问题基于现状引入以下的问题。 难以维护，当发现被拷过来的makefile有bug，需要将所有的makefile去改一次，特别是 有拷过来的文件有所特殊的改动时，还不能进行覆盖。 增加新特性时，比较麻烦。 方案makefile中公共的部分提出来，就像代码中的函数。需要用的地方去包含就行了。 补充几个必要的知识点,更详情的可以找makefile的文档来看（对于熟悉makefile的可以跳过） include。makefile解释到include指令的时候，停止当前文件的解释，去将include的 文件插到当前文件来，然后解释被include的文件。完成后再去解释当前文件剩下的部分。 目标。makefile最终的目的是生成我们要的目标。每个目标后面加一个冒号，后面加依 赖的文件。换行缩进一个tab，写命令。而makefile最张展开后的第一个目标是默认的 终极目标。我们可以在make的时候传入一个目标做为终极目标。终极目标会根据依赖进 行树状展开。 核心代码对于编译代码，跟目录层级进行make -C，我们要使用不同的规则。所以这里有两个不同核 心部分代码。 编译代码的makefile, 文件名comm.mk，这里的makefile.plib是我们工程里定义的一些 makefile变量，用于编译时传给gcc的头文件和库文件的查找路径。这里定义了INC_DIR, SRC_DIR等变量的目的是可以让需要进行编译的目录有一个可以自定义目录层次的入口。 默认一个目录下的头文件放在include下，源文件放在src下，生成的目标文件放在obj下， 生成的库文件放在lib下。目前看不懂，没关系。第3点会说怎么使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161include $(shell dirname $(PATH_MV_PRJ))/$(shell basename $(PATH_MV_PRJ))/plib/makefile.plibifndef INC_DIR INC_DIR = include/endififndef SRC_DIR SRC_DIR = src/endififndef OBJ_DIR OBJ_DIR = obj/endififndef LIB_DIR LIB_DIR = lib/endififndef OBJ_EXT OBJ_EXT = .oendififndef DEPEND_EXT DEPEND_EXT = .dendififndef CPPSRC_EXT CPPSRC_EXT = .cppendififndef PREPROCESS_EXT PREPROCESS_EXT = .eendififndef PRECOMPILE_EXT PRECOMPILE_EXT = .gchendififndef OBJECTS OBJECTS=$(patsubst $(SRC_DIR)%.cpp,$(OBJ_DIR)%.o,$(wildcard $(SRC_DIR)*.cpp))endififndef DEPENDS DEPENDS=$(patsubst $(SRC_DIR)%.cpp,$(OBJ_DIR)%.d,$(wildcard $(SRC_DIR)*.cpp))endififndef PRE_PROCESS_OBJS PRE_PROCESS_OBJS=$(patsubst $(SRC_DIR)%.cpp,$(OBJ_DIR)%.i,$(wildcard $(SRC_DIR)*.cpp))endifPWD=$(shell pwd)ifndef LIB_TARGET LIB_TARGET = $(LIB_DIR)lib$(TARGET_PREFIX)$(shell basename $(PWD))$(TARGET_POSTFIX).aendifALL+=$(LIB_TARGET)ifeq &quot;$(YCM_CONF)&quot; &quot;1&quot;ALL+=.ycm_extra_conf.pyendififeq &quot;$(HAS_GIT)&quot; &quot;1&quot;ALL+= $(OBJ_DIR).gitignore $(LIB_DIR).gitignoreendififdef NEED_GCHifndef PRE_COMPILE_OBJS PRE_COMPILE_OBJS=$(patsubst $(INC_DIR)%.h,$(INC_DIR)%.gch,$(wildcard $(INC_DIR)*.h))endifALL+= $(PRE_COMPILE_OBJS)$(OBJECTS): $(PRE_COMPILE_OBJS)$(PRE_COMPILE_OBJS): $(INC_DIR)%.gch: $(INC_DIR)%.h @echo -e &quot;\033[1;33m\nPrecompiling $&lt; ==&gt; $@ \033[0m...&quot; $(CXX) $(INC) $(C_FLAGS) $&lt; @echo &quot;&quot;endif.PHONY: all clean testall: $(ALL)test: @echo $(ALL)clean: rm $(OBJ_DIR)*$(OBJ_EXT) $(OBJ_DIR)*$(DEPEND_EXT) $(LIB_TARGET) $(PRE_COMPILE_OBJS) $(EXTRA) -rfifeq &quot;$(HAS_GIT)&quot; &quot;1&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;clean&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;test&quot;$(OBJ_DIR).gitignore: | $(OBJ_DIR) touch $@ifneq &quot;$(OBJ_DIR)&quot; &quot;$(LIB_DIR)&quot;$(LIB_DIR).gitignore: | $(LIB_DIR) touch $@endifendifendifendififneq &quot;$(MAKECMDGOALS)&quot; &quot;clean&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;test&quot;$(DEPENDS): $(OBJ_DIR)%$(DEPEND_EXT): $(SRC_DIR)%$(CPPSRC_EXT) | $(OBJ_DIR) @echo -e &quot;\033[1;33m\nCompiling $&lt; ==&gt; $@ \033[0m...&quot; @$(CXX) -MM $(INC) -I$(INC_DIR) $(C_FLAGS) $&lt; &gt; $@.$$$$; \ sed &apos;s,\($*\)\.o[ :]*,$(OBJ_DIR)\1.o $@ : ,g&apos; &lt; $@.$$$$ &gt; $@; \ rm -f $@.$$$$;endifendif$(OBJECTS): $(OBJ_DIR)%$(OBJ_EXT): $(SRC_DIR)%$(CPPSRC_EXT) | $(OBJ_DIR) @echo -e &quot;\033[1;33m\nCompiling $&lt; ==&gt; $@ \033[0m...&quot; $(CXX) $(INC) -I$(INC_DIR) $(C_FLAGS) -c $&lt; -o $@ @echo &quot;&quot;$(PRE_PROCESS_OBJS): $(OBJ_DIR)%.i: $(SRC_DIR)%$(CPPSRC_EXT) | $(OBJ_DIR) @echo -e &quot;\033[1;33m\nPreprocessing $&lt; ==&gt; $@ \033[0m...&quot; $(CXX) $(INC) -I$(INC_DIR) $(C_FLAGS) -E $&lt; &gt; $@ @echo &quot;&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;clean&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;test&quot;$(OBJ_DIR): -mkdir $@endifendififneq &quot;$(LIB_TARGET)&quot; &quot;&quot;# $(LIB_TARGET): | $(LIB_DIR)$(LIB_TARGET):$(OBJECTS) $(DEPENDS) | $(LIB_DIR) @echo &quot;$(OBJECTS) ==&gt; $@&quot; $(AR) rc $(LIB_TARGET) $(OBJECTS) @echo &quot;&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;clean&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;test&quot;ifneq &quot;$(OBJ_DIR)&quot; &quot;$(LIB_DIR)&quot;$(LIB_DIR): -mkdir $@endifendifendifendif.ycm_extra_conf.py: makefile $(shell dirname $(PATH_MV_PRJ))/$(shell basename $(PATH_MV_PRJ))/tools/generate_ycm.sh $(DEPENDS) @echo -e &quot;\033[1;33m\ngenerate .ycm_extra_conf \033[0m...&quot; $(shell dirname $(PATH_MV_PRJ))/$(shell basename $(PATH_MV_PRJ))/tools/generate_ycm.sh &quot;$(INC)&quot; @echo &quot;&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;clean&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;test&quot;sinclude $(DEPENDS)endifendif 目录层级使用make -C来编译下一层目录, dir.mk。这里通过FILTER_OUT来排除要编译的目录。 123456789101112131415161718include $(shell dirname $(PATH_MV_PRJ))/$(shell basename $(PATH_MV_PRJ))/plib/makefile.plibFILTER_OUT+=$(wildcard makefile*) tagsifndef ALL_DIRS ALL_DIRS=$(filter-out $(FILTER_OUT), $(wildcard *))endif.PHONY: all clean $(ALL_DIRS)all: $(ALL_DIRS)clean: $(ALL_DIRS)$(ALL_DIRS): if [ -f $@/makefile ] ; \ then \ $(MAKE) -C $@ $(MAKECMDGOALS) ; \ fi 下面以我的工程中的comm_process目录来进行讲解一下普通目录的编译。目录树如下。 1234567~/m/a/s/comm_process(master) $ tree -L 1.|-- include|-- lib|-- makefile|-- obj`-- src makefile文件内容如下： 123456include $(shell dirname $(PATH_MV_PRJ))/$(shell basename $(PATH_MV_PRJ))/makeinclude/comm.mkINC+=-I./includeINC+=$(INC_MOBILE_TAIL_API) $(INC_SHARE_BUIS_COMM)LIB_TARGET=lib/libcommprocess.a 这个文件一开头就去include了我们之前的comm.mk文件，里面定义了各个编译.cpp，生成 目标文件的规则。而INC变量，可以在comm.mk的OBJECT生成规则那里用到，用于提供给 gcc -I进行查找头文件。而INC_MOBILE_TAIL_API， INC_SHARE_BUIS_COMM这些变量定义 在我们之前说的那个makefle.plib下。 一定定义成这样： 1INC_MOBILE_TAIL_API=-I../mobile_tail_api/include 下面介绍目录层级的makefile, 里面定义的规则是跳到下一级目录下去进行编译。以下 的目录结构如下： 1234567891011121314~/m/a/share(master) $ tree -L 1.|-- busi_comm|-- comm_process|-- makefile|-- mt_spp|-- mysql|-- protocol|-- server_frame|-- task|-- task_frame`-- webapp_frame9 directories, 1 file makefile如下： 12FILTER_OUT+=mt_sppinclude $(shell dirname $(PATH_MV_PRJ))/$(shell basename $(PATH_MV_PRJ))/makeinclude/dir.mk 首先加入一些我们不希望编译的目录在FILTER_OUT里面。然后include我们第2点的dir.mk 文件。然后在这层目录进行make，就会进行跳到各个目录去编译了。 到这里，会发现还不能达到我们项目的要求。我们项目一般是编出来一个动态库或者一 个可执行文件。而我们上面编出来的只是静态库。我们可以根据在comm.mk的基础上去加规 则来生成动态库或者可执行文件。以下以生成一个动态库为例子。 mtserver.mk 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859ifndef LIB_DIR LIB_DIR = bin/endififndef BIN_TARGET BIN_TARGET = $(LIB_DIR)lib$(TARGET_PREFIX)$(shell basename $(shell basename $(PWD)))$(TARGET_POSTFIX).soendifBIN_SO_NAME = $(word $(words $(subst /, ,$(BIN_TARGET))), $(subst /, ,$(BIN_TARGET)))BIN_LIB=$(shell dirname $(BIN_TARGET))LIB_TARGET=ALL+=$(BIN_TARGET)EXTRA+=$(BIN_TARGET)ifeq &quot;$(HAS_GIT)&quot; &quot;1&quot;ALL+=$(BIN_DIR).gitignoreendifinclude $(shell dirname $(PATH_MV_PRJ))/$(shell basename $(PATH_MV_PRJ))/makeinclude/comm.mkSO_DIR=$(PATH_PROJ_ROOT)/soSTRIP_SO_DIR=$(PATH_PROJ_ROOT)/strip_so$(BIN_TARGET): $(OBJECTS) $(DEPENDS) @echo -e &quot;\033[1;33m\nCompiling $&lt; ==&gt; $@ \033[0m...&quot; $(CXX) $(INC) $(C_FLAGS) -shared -Wl,-rpath,/usr/local/qzone/lib $(PATH_PROJ_ROOT)/application/share/server_frame/obj/service.o $(OBJECTS) $(LIB) -lz -o $@ ; \ $(PATH_PROJ_ROOT)/tools/check_symbol.sh $@; \ if [ $$? -eq 0 ]; then \ cp $@ $(SO_DIR) ;\ cp $@ $(STRIP_SO_DIR); \ strip $(STRIP_SO_DIR)/$(BIN_SO_NAME); \ fi;$(ALL) : del_target$(BIN_TARGET): | $(BIN_DIR)ifneq &quot;$(MAKECMDGOALS)&quot; &quot;clean&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;test&quot;$(BIN_DIR): -mkdir $@endifendififeq &quot;$(HAS_GIT)&quot; &quot;1&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;clean&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;test&quot;$(BIN_DIR).gitignore: | $(BIN_DIR) touch $@endifendifendif.PHONY:del_targetdel_target: $(RM) bin/* 这里我们一样include了comm.mk，然后在它的基础上去编译生成动态库。 到目前，我们的规则可以生成动态库了。但是还存在一个问题，就是同层目录，可能编 译会有先后顺序的问题，比如，我要先编好share目录，才能去编业务的so目录。如以下的 目录结构： 123456789~/m/application(master) $ tree -L 1.|-- makefile|-- server|-- share|-- tools`-- webapps4 directories, 1 file makefile如下： 123456~/m/application(master) $ cat makefileinclude $(shell dirname $(PATH_MV_PRJ))/$(shell basename $(PATH_MV_PRJ))/makeinclude/dir.mkWITHOUT_SHARE=$(filter-out share, $(ALL_DIRS))$(WITHOUT_SHARE): share 会发现，其实makefile跟其他跳去编下一层目录的makefile差不多，就是多了最后两行。 倒数第二行，是将目录文件将share去掉，最后一行是将除了share目录的其他目录编译都 需要先依赖share目录编译完才会去编译。 到这里我们的整个工程makefile都可以使用上面定义的comm.mk，dir.mk，mtserver.mk目录 进行组织了。 总结一下改造的过程 编写comm.mk，dir.mk，放在工程比较顶层的目录中，以便其他目录去include。 编写特殊的makefile，如mtserver.mk文件，以便生成特殊上目标文件（如.so）去include。 从工程的根目录开始，如果当前目录下放的是一些子目录，则写一个makefile，去 include dir.mk。如果当前目录下放的是src include obj lib的文件，里面分别放了 .cpp .h文件，则去include comm.mk文件，如果当前目录下没有src include obj lib 目录来组织.cpp .h文件，则将INC_DIR SRC_DIR OBJ_DIR LIB_DIR赋空，再去include comm.mk文件。]]></content>
      <categories>
        <category>工程管理</category>
      </categories>
      <tags>
        <tag>后台</tag>
        <tag>c</tag>
        <tag>c++</tag>
      </tags>
  </entry>
</search>
