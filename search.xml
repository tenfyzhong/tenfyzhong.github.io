<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[complete_parameter]]></title>
    <url>%2F2017%2F09%2F02%2Fcomplete-parameter%2F</url>
    <content type="text"><![CDATA[YouCompleteMe给vim做补全非常方便，但是补全出函数后，却不会补全上参数。这是一个辅助YouCompleteMe、deoplete、neocomplete补全插件进行补全参数的插件。 前言YouCompleteMe给vim做补全非常方便，但是补全出函数后，却不会补全上参数。这是一个辅助YouCompleteMe、deoplete、neocomplete补全插件进行补全参数的插件。从此函数补全完后，再也不用跳去看声明参数要怎么填了。插件链接：tenfyzhong/CompleteParameter.vim 只有补全引擎的vim注：以下所有的例子都以YouCompleteMe为例子，使用deoplete、neocomplete也是一样的。并且以golang为例子，当然目前已经支持了多种语言，详细请看github上的README字不重要，看下图：ycm呼起了补全菜单，选中补全列表中的一项后，按左括号开始填参数。对于大的函数，这时候就蒙圈了，忘了要填什么参数了。就只有跳到函数声明或者文档上去看参数，而且经常是看了第一个，回来填好后，再去看第二个，如此循环。 参数补全闪亮登场继续看图：还是ycm呼起了补全菜单，选中补全列表中的一项后，按左括号，形参的名字已经补全上来了，并且这时使用选择模式选中了第一个参数，直接输入内容，当前选中的内容就会被删除，而插入输入的内容。第一个参数填完后，按&lt;m-n&gt;(默认跳转到下一个参数的映射键)，就跳到第二个参数，并且又进入了选择模式。修改完后，就可以继续按&lt;m-n&gt;跳到下一个参数(如果没有下一个参数了，则会跳到右括号之后，并且进行插入模式)。当跳到下一个参数后发现上一个参数输错了，这时还可以通过&lt;m-p&gt;来跳回到上一个参数，并且选择了它，又可以进行修改了。有时候调用函数，已经有了跟形参一样名字的变量了，这时候补全完之后，因为插入的形参名字和变量名字一样，这时候就不用修改了。直接按&lt;m-n&gt;跳到下一个位置即可。 已经支持的语言(截止到2017年7月1日) c c++ golang python erlang javascript typescript rust]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工程makefile管理的一种比较合理的方案]]></title>
    <url>%2F2017%2F09%2F01%2Fproject-makefile%2F</url>
    <content type="text"><![CDATA[现状可以说makefile也是代码，都是命令的集合。代码臭味中最出名的算是重复代码了。而工程中的makefile存在这样的情况。每新建一个目录，就将别的目录下的makefile拷过来，这个makefile文件包含了进行编译的所有指令。 这篇文章将会让你的Makefile清晰明了。 问题基于现状引入以下的问题。 难以维护，当发现被拷过来的makefile有bug，需要将所有的makefile去改一次，特别是有拷过来的文件有所特殊的改动时，还不能进行覆盖。 增加新特性时，比较麻烦。 方案makefile中公共的部分提出来，就像代码中的函数。需要用的地方去包含就行了。 补充几个必要的知识点,更详情的可以找makefile的文档来看（对于熟悉makefile的可以跳过） include。makefile解释到include指令的时候，停止当前文件的解释，去将include的文件插到当前文件来，然后解释被include的文件。完成后再去解释当前文件剩下的部分。 目标。makefile最终的目的是生成我们要的目标。每个目标后面加一个冒号，后面加依赖的文件。换行缩进一个tab，写命令。而makefile最张展开后的第一个目标是默认的终极目标。我们可以在make的时候传入一个目标做为终极目标。终极目标会根据依赖进行树状展开。 核心代码对于编译代码，跟目录层级进行make -C，我们要使用不同的规则。所以这里有两个不同核心部分代码。 编译代码的makefile, 文件名comm.mk，这里的makefile.plib是我们工程里定义的一些makefile变量，用于编译时传给gcc的头文件和库文件的查找路径。这里定义了INC_DIR,SRC_DIR等变量的目的是可以让需要进行编译的目录有一个可以自定义目录层次的入口。默认一个目录下的头文件放在include下，源文件放在src下，生成的目标文件放在obj下，生成的库文件放在lib下。目前看不懂，没关系。第3点会说怎么使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161include $(shell dirname $(PATH_MV_PRJ))/$(shell basename $(PATH_MV_PRJ))/plib/makefile.plibifndef INC_DIR INC_DIR = include/endififndef SRC_DIR SRC_DIR = src/endififndef OBJ_DIR OBJ_DIR = obj/endififndef LIB_DIR LIB_DIR = lib/endififndef OBJ_EXT OBJ_EXT = .oendififndef DEPEND_EXT DEPEND_EXT = .dendififndef CPPSRC_EXT CPPSRC_EXT = .cppendififndef PREPROCESS_EXT PREPROCESS_EXT = .eendififndef PRECOMPILE_EXT PRECOMPILE_EXT = .gchendififndef OBJECTS OBJECTS=$(patsubst $(SRC_DIR)%.cpp,$(OBJ_DIR)%.o,$(wildcard $(SRC_DIR)*.cpp))endififndef DEPENDS DEPENDS=$(patsubst $(SRC_DIR)%.cpp,$(OBJ_DIR)%.d,$(wildcard $(SRC_DIR)*.cpp))endififndef PRE_PROCESS_OBJS PRE_PROCESS_OBJS=$(patsubst $(SRC_DIR)%.cpp,$(OBJ_DIR)%.i,$(wildcard $(SRC_DIR)*.cpp))endifPWD=$(shell pwd)ifndef LIB_TARGET LIB_TARGET = $(LIB_DIR)lib$(TARGET_PREFIX)$(shell basename $(PWD))$(TARGET_POSTFIX).aendifALL+=$(LIB_TARGET)ifeq &quot;$(YCM_CONF)&quot; &quot;1&quot;ALL+=.ycm_extra_conf.pyendififeq &quot;$(HAS_GIT)&quot; &quot;1&quot;ALL+= $(OBJ_DIR).gitignore $(LIB_DIR).gitignoreendififdef NEED_GCHifndef PRE_COMPILE_OBJS PRE_COMPILE_OBJS=$(patsubst $(INC_DIR)%.h,$(INC_DIR)%.gch,$(wildcard $(INC_DIR)*.h))endifALL+= $(PRE_COMPILE_OBJS)$(OBJECTS): $(PRE_COMPILE_OBJS)$(PRE_COMPILE_OBJS): $(INC_DIR)%.gch: $(INC_DIR)%.h @echo -e &quot;\033[1;33m\nPrecompiling $&lt; ==&gt; $@ \033[0m...&quot; $(CXX) $(INC) $(C_FLAGS) $&lt; @echo &quot;&quot;endif.PHONY: all clean testall: $(ALL)test: @echo $(ALL)clean: rm $(OBJ_DIR)*$(OBJ_EXT) $(OBJ_DIR)*$(DEPEND_EXT) $(LIB_TARGET) $(PRE_COMPILE_OBJS) $(EXTRA) -rfifeq &quot;$(HAS_GIT)&quot; &quot;1&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;clean&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;test&quot;$(OBJ_DIR).gitignore: | $(OBJ_DIR) touch $@ifneq &quot;$(OBJ_DIR)&quot; &quot;$(LIB_DIR)&quot;$(LIB_DIR).gitignore: | $(LIB_DIR) touch $@endifendifendifendififneq &quot;$(MAKECMDGOALS)&quot; &quot;clean&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;test&quot;$(DEPENDS): $(OBJ_DIR)%$(DEPEND_EXT): $(SRC_DIR)%$(CPPSRC_EXT) | $(OBJ_DIR) @echo -e &quot;\033[1;33m\nCompiling $&lt; ==&gt; $@ \033[0m...&quot; @$(CXX) -MM $(INC) -I$(INC_DIR) $(C_FLAGS) $&lt; &gt; $@.$$$$; \ sed &apos;s,\($*\)\.o[ :]*,$(OBJ_DIR)\1.o $@ : ,g&apos; &lt; $@.$$$$ &gt; $@; \ rm -f $@.$$$$;endifendif$(OBJECTS): $(OBJ_DIR)%$(OBJ_EXT): $(SRC_DIR)%$(CPPSRC_EXT) | $(OBJ_DIR) @echo -e &quot;\033[1;33m\nCompiling $&lt; ==&gt; $@ \033[0m...&quot; $(CXX) $(INC) -I$(INC_DIR) $(C_FLAGS) -c $&lt; -o $@ @echo &quot;&quot;$(PRE_PROCESS_OBJS): $(OBJ_DIR)%.i: $(SRC_DIR)%$(CPPSRC_EXT) | $(OBJ_DIR) @echo -e &quot;\033[1;33m\nPreprocessing $&lt; ==&gt; $@ \033[0m...&quot; $(CXX) $(INC) -I$(INC_DIR) $(C_FLAGS) -E $&lt; &gt; $@ @echo &quot;&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;clean&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;test&quot;$(OBJ_DIR): -mkdir $@endifendififneq &quot;$(LIB_TARGET)&quot; &quot;&quot;# $(LIB_TARGET): | $(LIB_DIR)$(LIB_TARGET):$(OBJECTS) $(DEPENDS) | $(LIB_DIR) @echo &quot;$(OBJECTS) ==&gt; $@&quot; $(AR) rc $(LIB_TARGET) $(OBJECTS) @echo &quot;&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;clean&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;test&quot;ifneq &quot;$(OBJ_DIR)&quot; &quot;$(LIB_DIR)&quot;$(LIB_DIR): -mkdir $@endifendifendifendif.ycm_extra_conf.py: makefile $(shell dirname $(PATH_MV_PRJ))/$(shell basename $(PATH_MV_PRJ))/tools/generate_ycm.sh $(DEPENDS) @echo -e &quot;\033[1;33m\ngenerate .ycm_extra_conf \033[0m...&quot; $(shell dirname $(PATH_MV_PRJ))/$(shell basename $(PATH_MV_PRJ))/tools/generate_ycm.sh &quot;$(INC)&quot; @echo &quot;&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;clean&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;test&quot;sinclude $(DEPENDS)endifendif 目录层级使用make -C来编译下一层目录, dir.mk。这里通过FILTER_OUT来排除要编译的目录。 123456789101112131415161718include $(shell dirname $(PATH_MV_PRJ))/$(shell basename $(PATH_MV_PRJ))/plib/makefile.plibFILTER_OUT+=$(wildcard makefile*) tagsifndef ALL_DIRS ALL_DIRS=$(filter-out $(FILTER_OUT), $(wildcard *))endif.PHONY: all clean $(ALL_DIRS)all: $(ALL_DIRS)clean: $(ALL_DIRS)$(ALL_DIRS): if [ -f $@/makefile ] ; \ then \ $(MAKE) -C $@ $(MAKECMDGOALS) ; \ fi 下面以我的工程中的comm_process目录来进行讲解一下普通目录的编译。目录树如下。 1234567~/m/a/s/comm_process(master) $ tree -L 1.|-- include|-- lib|-- makefile|-- obj`-- src makefile文件内容如下： 123456include $(shell dirname $(PATH_MV_PRJ))/$(shell basename $(PATH_MV_PRJ))/makeinclude/comm.mkINC+=-I./includeINC+=$(INC_MOBILE_TAIL_API) $(INC_SHARE_BUIS_COMM)LIB_TARGET=lib/libcommprocess.a 这个文件一开头就去include了我们之前的comm.mk文件，里面定义了各个编译.cpp，生成目标文件的规则。而INC变量，可以在comm.mk的OBJECT生成规则那里用到，用于提供给gcc -I进行查找头文件。而INC_MOBILE_TAIL_API， INC_SHARE_BUIS_COMM这些变量定义在我们之前说的那个makefle.plib下。一定定义成这样： 1INC_MOBILE_TAIL_API=-I../mobile_tail_api/include 下面介绍目录层级的makefile, 里面定义的规则是跳到下一级目录下去进行编译。以下的目录结构如下： 1234567891011121314~/m/a/share(master) $ tree -L 1.|-- busi_comm|-- comm_process|-- makefile|-- mt_spp|-- mysql|-- protocol|-- server_frame|-- task|-- task_frame`-- webapp_frame9 directories, 1 file makefile如下： 12FILTER_OUT+=mt_sppinclude $(shell dirname $(PATH_MV_PRJ))/$(shell basename $(PATH_MV_PRJ))/makeinclude/dir.mk 首先加入一些我们不希望编译的目录在FILTER_OUT里面。然后include我们第2点的dir.mk文件。然后在这层目录进行make，就会进行跳到各个目录去编译了。 到这里，会发现还不能达到我们项目的要求。我们项目一般是编出来一个动态库或者一个可执行文件。而我们上面编出来的只是静态库。我们可以根据在comm.mk的基础上去加规则来生成动态库或者可执行文件。以下以生成一个动态库为例子。 mtserver.mk 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859ifndef LIB_DIR LIB_DIR = bin/endififndef BIN_TARGET BIN_TARGET = $(LIB_DIR)lib$(TARGET_PREFIX)$(shell basename $(shell basename $(PWD)))$(TARGET_POSTFIX).soendifBIN_SO_NAME = $(word $(words $(subst /, ,$(BIN_TARGET))), $(subst /, ,$(BIN_TARGET)))BIN_LIB=$(shell dirname $(BIN_TARGET))LIB_TARGET=ALL+=$(BIN_TARGET)EXTRA+=$(BIN_TARGET)ifeq &quot;$(HAS_GIT)&quot; &quot;1&quot;ALL+=$(BIN_DIR).gitignoreendifinclude $(shell dirname $(PATH_MV_PRJ))/$(shell basename $(PATH_MV_PRJ))/makeinclude/comm.mkSO_DIR=$(PATH_PROJ_ROOT)/soSTRIP_SO_DIR=$(PATH_PROJ_ROOT)/strip_so$(BIN_TARGET): $(OBJECTS) $(DEPENDS) @echo -e &quot;\033[1;33m\nCompiling $&lt; ==&gt; $@ \033[0m...&quot; $(CXX) $(INC) $(C_FLAGS) -shared -Wl,-rpath,/usr/local/qzone/lib $(PATH_PROJ_ROOT)/application/share/server_frame/obj/service.o $(OBJECTS) $(LIB) -lz -o $@ ; \ $(PATH_PROJ_ROOT)/tools/check_symbol.sh $@; \ if [ $$? -eq 0 ]; then \ cp $@ $(SO_DIR) ;\ cp $@ $(STRIP_SO_DIR); \ strip $(STRIP_SO_DIR)/$(BIN_SO_NAME); \ fi;$(ALL) : del_target$(BIN_TARGET): | $(BIN_DIR)ifneq &quot;$(MAKECMDGOALS)&quot; &quot;clean&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;test&quot;$(BIN_DIR): -mkdir $@endifendififeq &quot;$(HAS_GIT)&quot; &quot;1&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;clean&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;test&quot;$(BIN_DIR).gitignore: | $(BIN_DIR) touch $@endifendifendif.PHONY:del_targetdel_target: $(RM) bin/* 这里我们一样include了comm.mk，然后在它的基础上去编译生成动态库。 到目前，我们的规则可以生成动态库了。但是还存在一个问题，就是同层目录，可能编译会有先后顺序的问题，比如，我要先编好share目录，才能去编业务的so目录。如以下的目录结构： 123456789~/m/application(master) $ tree -L 1.|-- makefile|-- server|-- share|-- tools`-- webapps4 directories, 1 file makefile如下： 123456~/m/application(master) $ cat makefileinclude $(shell dirname $(PATH_MV_PRJ))/$(shell basename $(PATH_MV_PRJ))/makeinclude/dir.mkWITHOUT_SHARE=$(filter-out share, $(ALL_DIRS))$(WITHOUT_SHARE): share 会发现，其实makefile跟其他跳去编下一层目录的makefile差不多，就是多了最后两行。倒数第二行，是将目录文件将share去掉，最后一行是将除了share目录的其他目录编译都需要先依赖share目录编译完才会去编译。 到这里我们的整个工程makefile都可以使用上面定义的comm.mk，dir.mk，mtserver.mk目录进行组织了。 总结一下改造的过程 编写comm.mk，dir.mk，放在工程比较顶层的目录中，以便其他目录去include。 编写特殊的makefile，如mtserver.mk文件，以便生成特殊上目标文件（如.so）去include。 从工程的根目录开始，如果当前目录下放的是一些子目录，则写一个makefile，去include dir.mk。如果当前目录下放的是src include obj lib的文件，里面分别放了.cpp .h文件，则去include comm.mk文件，如果当前目录下没有src include obj lib目录来组织.cpp .h文件，则将INC_DIR SRC_DIR OBJ_DIR LIB_DIR赋空，再去include comm.mk文件。]]></content>
      <categories>
        <category>工程管理</category>
      </categories>
      <tags>
        <tag>后台</tag>
        <tag>c</tag>
        <tag>c++</tag>
      </tags>
  </entry>
</search>
