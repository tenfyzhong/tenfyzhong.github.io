<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Golang直接操作共享内存]]></title>
    <url>%2F2017%2F09%2F02%2Fgolang-share-memory%2F</url>
    <content type="text"><![CDATA[Golang不使用cgo，直接操作共享内存。 前言故事起源于要搭一个高性能的日志中心。当然使用了elk这一套。但是，对于logstash来说，它主要使用的是文件日志的方式了捕捉log。而写文件日志的话会非常慢。对于实时日志要处理滚动的日志更是这样，每次检查是否需要流动日志，然后打开日志，然后写入，然后关闭，当然这中间可以优化。这一切都是那么慢，发起了n个系统调用，硬盘寻道等。这时候想到了用共享内存来通信。 共享内存的基本知识要使用共享内存要执行以下几步： 发起一个系统调用，让系统帮你生产一块内存，或者取得一块已经存在的内存来使用。 把内存attach到当前进程，让当前进程可以使用。大家都知道，我们在进程中访问的是虚拟内存地址，系统会把它映射到物理内存中。如果没有这一步，第1步创建的内存就不能在当前进程访问。 这时就可以对内存进程读写操作了。 进程结束的时候要把上面attach的内存给释放。 系统调用的基础知识什么是系统调用? 系统调用（英语：system call），又称为系统呼叫，指运行在使用者空间的程序向操作 系统内核请求需要更高权限运行的服务。系统调用提供用户程序与操作系统之间的接口。 以上引自维基百科。 对于每个系统调用，都一个编号。内核收到编号后，就根据编号去找到对应的内核函数函数来执行。然后返回给应用程序。 系统调用是怎么发起的？以下以linux为例。 应用程序以系统调用号和对应的参数传给系统调用api 系统调用api将系统调用号存到eax中，然后发起0x80的中断号进行中断 内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用） 系统调用完成相应功能，将返回值存入 eax，返回到中断处理函数 中断处理函数返回到 API 中 API 将 eax 返回给应用程序 以上就完成了系统调用。 在golang中使用共享内存了解了系统调用之后，下面就开始使用了。第一步当然是去找golang有没有直接提供共享内存的api了。几经折腾后，发现它并没有提供直接的api。而其他很多系统调用都提供了直接的api。究其原因，我想应该是因为这句话吧： “不要通过共享内存来通信，而应该通过通信来共享内存” golang不提供使用共享内存来通信。所以直接不提供了，折腾死你们，让你们用不了。于是乎，google一下解决方案，都是通过cgo来调c语言来实现的。stackoverflow的答案也都是这样。回来再来看一下golang的syscall的文档。它提供了Syscall函数。声明如下：1func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno) 很显示trap是中断号，a1, a2, a3是系统调用相关的参数。对于中断号，在文档中可以看到，所有的系统都已经定义了常量了。而我们要用到的系统调用有：SYS_SHMGET: 创建或者取得共享内存。SYS_SHMAT: 将共享内存attach到当前进程空间。SYS_SHMDT: 将共享内存从当前进程中deattach。 具体这三个函数的使用，我们可以参考linux的shmget, shmat, shmdt函数。可以看到这三个函数跟上面三个系统调用号的常量名字一样的。以下是这三个函数的声明：123int shmget(key_t key, size_t size, int shmflg); void *shmat(int shm_id, const void *shm_addr, int shmflg); int shmdt(const void *shmaddr); 以下简单介绍一下这三个函数，具体可以直接去linux上man对应的文档。 shmget函数key，这个参数的类型key_y其实只是一个数字类型。这个参数命名了这一块内存。不要提供0值就行了，0值是private的，不能在进程间共享。size，提供了共享内存的大小。shmflg，权限标志，它的作用与open函数的mode参数一样。如果需要在内存不存在时创建它，则需要指定IPC_CREAT。在golang的文档中可以看到，它并没定义IPC_CREATE的值。所以我们只能去找到它的值了。在linux的man文档中，它也没有说明。于是乎，直接把linux的代码clone下来进行了grep(我用ag，速度非常快的文档查找工具)。从结果中找到了IPC_CREATE是一个宏，它的值定义成了00001000。一个8进制的数字。低三位都是0，因为低三位是用来标志权限位的。 下面我们直接来发起这个系统调用看一下效果，把调用c的参数一一对应到a1, a2, a3中：1shmid, _, err := syscall.Syscall(syscall.SYS_SHMGET, 2, 4, IpcCreate|0600) Syscall函数返回了两个值和一个error字段。而c的shmget只返回了一个int值，因为这个函数把结果错误和结果都通过返回值来承载了，如果是小于0的，则是错误，这时对应到go中应该是err的值，没有错误的时候，我们只需要一个返回值，第二个返回值会一直是0。第一个返回值就是给shmat调用的第一个参数。 shmat函数shm_id, 这是shmget返回id，以标志了要attach的是这一块内存shm_addr，这个标志需要把它attach到的内存地址，通常填0，让系统去选择地址来attachshmflg，这个可以值SHM_RDONLY表示只读，其他值为可以读写，我们直接传0就好。 1shmaddr, _, err := syscall.Syscall(syscall.SYS_SHMAT, shmid, 0, 0) c函数返回了进程空间地址，这个调用也是只返回了一个值，所我们只接收第一个值。在c中，如果调用失败，会返回-1。在go中，我们只要直接处理err的值就好了。 shmdt函数shmaddr, 这个参数表示deattach的地址值，是从shmat中返回的。我们在go中直接用defer来调用就好了：1defer syscall.Syscall(syscall.SYS_SHMDT, shmaddr, 0, 0) 以下是这个blog用到的代码，可以直接从gist里去下载：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// @file main.go// @brief// @author tenfyzhong// @email tenfyzhong@qq.com// @created 2017-06-26 17:54:34package mainimport ( "flag" "fmt" "os" "syscall" "time" "unsafe")const ( // IpcCreate create if key is nonexistent IpcCreate = 00001000)var mode = flag.Int("mode", 0, "0:write 1:read")func main() &#123; flag.Parse() shmid, _, err := syscall.Syscall(syscall.SYS_SHMGET, 2, 4, IpcCreate|0600) if err != 0 &#123; fmt.Printf("syscall error, err: %v\n", err) os.Exit(-1) &#125; fmt.Printf("shmid: %v\n", shmid) shmaddr, _, err := syscall.Syscall(syscall.SYS_SHMAT, shmid, 0, 0) if err != 0 &#123; fmt.Printf("syscall error, err: %v\n", err) os.Exit(-2) &#125; fmt.Printf("shmaddr: %v\n", shmaddr) defer syscall.Syscall(syscall.SYS_SHMDT, shmaddr, 0, 0) if *mode == 0 &#123; fmt.Println("write mode") i := 0 for &#123; fmt.Printf("%d\n", i) *(*int)(unsafe.Pointer(uintptr(shmaddr))) = i i++ time.Sleep(1 * time.Second) &#125; &#125; else &#123; fmt.Println("read mode") for &#123; fmt.Println(*(*int)(unsafe.Pointer(uintptr(shmaddr)))) time.Sleep(1 * time.Second) &#125; &#125;&#125; 运行一下这个代码块看一下结果：用ipcs可以看到共享已经成功创建。 对于共享内存的操作，大家还可以看一下shmctl这个系统调用的使用。]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[complete_parameter]]></title>
    <url>%2F2017%2F09%2F02%2Fcomplete-parameter%2F</url>
    <content type="text"><![CDATA[YouCompleteMe给vim做补全非常方便，但是补全出函数后，却不会补全上参数。这是一个辅助YouCompleteMe、deoplete、neocomplete补全插件进行补全参数的插件。 前言YouCompleteMe给vim做补全非常方便，但是补全出函数后，却不会补全上参数。这是一个辅助YouCompleteMe、deoplete、neocomplete补全插件进行补全参数的插件。从此函数补全完后，再也不用跳去看声明参数要怎么填了。插件链接：tenfyzhong/CompleteParameter.vim 只有补全引擎的vim注：以下所有的例子都以YouCompleteMe为例子，使用deoplete、neocomplete也是一样的。并且以golang为例子，当然目前已经支持了多种语言，详细请看github上的README字不重要，看下图：ycm呼起了补全菜单，选中补全列表中的一项后，按左括号开始填参数。对于大的函数，这时候就蒙圈了，忘了要填什么参数了。就只有跳到函数声明或者文档上去看参数，而且经常是看了第一个，回来填好后，再去看第二个，如此循环。 参数补全闪亮登场继续看图：还是ycm呼起了补全菜单，选中补全列表中的一项后，按左括号，形参的名字已经补全上来了，并且这时使用选择模式选中了第一个参数，直接输入内容，当前选中的内容就会被删除，而插入输入的内容。第一个参数填完后，按&lt;m-n&gt;(默认跳转到下一个参数的映射键)，就跳到第二个参数，并且又进入了选择模式。修改完后，就可以继续按&lt;m-n&gt;跳到下一个参数(如果没有下一个参数了，则会跳到右括号之后，并且进行插入模式)。当跳到下一个参数后发现上一个参数输错了，这时还可以通过&lt;m-p&gt;来跳回到上一个参数，并且选择了它，又可以进行修改了。有时候调用函数，已经有了跟形参一样名字的变量了，这时候补全完之后，因为插入的形参名字和变量名字一样，这时候就不用修改了。直接按&lt;m-n&gt;跳到下一个位置即可。 已经支持的语言(截止到2017年7月1日) c c++ golang python erlang javascript typescript rust]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工程makefile管理的一种比较合理的方案]]></title>
    <url>%2F2017%2F09%2F01%2Fproject-makefile%2F</url>
    <content type="text"><![CDATA[现状可以说makefile也是代码，都是命令的集合。代码臭味中最出名的算是重复代码了。而工程中的makefile存在这样的情况。每新建一个目录，就将别的目录下的makefile拷过来，这个makefile文件包含了进行编译的所有指令。 这篇文章将会让你的Makefile清晰明了。 问题基于现状引入以下的问题。 难以维护，当发现被拷过来的makefile有bug，需要将所有的makefile去改一次，特别是有拷过来的文件有所特殊的改动时，还不能进行覆盖。 增加新特性时，比较麻烦。 方案makefile中公共的部分提出来，就像代码中的函数。需要用的地方去包含就行了。 补充几个必要的知识点,更详情的可以找makefile的文档来看（对于熟悉makefile的可以跳过） include。makefile解释到include指令的时候，停止当前文件的解释，去将include的文件插到当前文件来，然后解释被include的文件。完成后再去解释当前文件剩下的部分。 目标。makefile最终的目的是生成我们要的目标。每个目标后面加一个冒号，后面加依赖的文件。换行缩进一个tab，写命令。而makefile最张展开后的第一个目标是默认的终极目标。我们可以在make的时候传入一个目标做为终极目标。终极目标会根据依赖进行树状展开。 核心代码对于编译代码，跟目录层级进行make -C，我们要使用不同的规则。所以这里有两个不同核心部分代码。 编译代码的makefile, 文件名comm.mk，这里的makefile.plib是我们工程里定义的一些makefile变量，用于编译时传给gcc的头文件和库文件的查找路径。这里定义了INC_DIR,SRC_DIR等变量的目的是可以让需要进行编译的目录有一个可以自定义目录层次的入口。默认一个目录下的头文件放在include下，源文件放在src下，生成的目标文件放在obj下，生成的库文件放在lib下。目前看不懂，没关系。第3点会说怎么使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161include $(shell dirname $(PATH_MV_PRJ))/$(shell basename $(PATH_MV_PRJ))/plib/makefile.plibifndef INC_DIR INC_DIR = include/endififndef SRC_DIR SRC_DIR = src/endififndef OBJ_DIR OBJ_DIR = obj/endififndef LIB_DIR LIB_DIR = lib/endififndef OBJ_EXT OBJ_EXT = .oendififndef DEPEND_EXT DEPEND_EXT = .dendififndef CPPSRC_EXT CPPSRC_EXT = .cppendififndef PREPROCESS_EXT PREPROCESS_EXT = .eendififndef PRECOMPILE_EXT PRECOMPILE_EXT = .gchendififndef OBJECTS OBJECTS=$(patsubst $(SRC_DIR)%.cpp,$(OBJ_DIR)%.o,$(wildcard $(SRC_DIR)*.cpp))endififndef DEPENDS DEPENDS=$(patsubst $(SRC_DIR)%.cpp,$(OBJ_DIR)%.d,$(wildcard $(SRC_DIR)*.cpp))endififndef PRE_PROCESS_OBJS PRE_PROCESS_OBJS=$(patsubst $(SRC_DIR)%.cpp,$(OBJ_DIR)%.i,$(wildcard $(SRC_DIR)*.cpp))endifPWD=$(shell pwd)ifndef LIB_TARGET LIB_TARGET = $(LIB_DIR)lib$(TARGET_PREFIX)$(shell basename $(PWD))$(TARGET_POSTFIX).aendifALL+=$(LIB_TARGET)ifeq &quot;$(YCM_CONF)&quot; &quot;1&quot;ALL+=.ycm_extra_conf.pyendififeq &quot;$(HAS_GIT)&quot; &quot;1&quot;ALL+= $(OBJ_DIR).gitignore $(LIB_DIR).gitignoreendififdef NEED_GCHifndef PRE_COMPILE_OBJS PRE_COMPILE_OBJS=$(patsubst $(INC_DIR)%.h,$(INC_DIR)%.gch,$(wildcard $(INC_DIR)*.h))endifALL+= $(PRE_COMPILE_OBJS)$(OBJECTS): $(PRE_COMPILE_OBJS)$(PRE_COMPILE_OBJS): $(INC_DIR)%.gch: $(INC_DIR)%.h @echo -e &quot;\033[1;33m\nPrecompiling $&lt; ==&gt; $@ \033[0m...&quot; $(CXX) $(INC) $(C_FLAGS) $&lt; @echo &quot;&quot;endif.PHONY: all clean testall: $(ALL)test: @echo $(ALL)clean: rm $(OBJ_DIR)*$(OBJ_EXT) $(OBJ_DIR)*$(DEPEND_EXT) $(LIB_TARGET) $(PRE_COMPILE_OBJS) $(EXTRA) -rfifeq &quot;$(HAS_GIT)&quot; &quot;1&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;clean&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;test&quot;$(OBJ_DIR).gitignore: | $(OBJ_DIR) touch $@ifneq &quot;$(OBJ_DIR)&quot; &quot;$(LIB_DIR)&quot;$(LIB_DIR).gitignore: | $(LIB_DIR) touch $@endifendifendifendififneq &quot;$(MAKECMDGOALS)&quot; &quot;clean&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;test&quot;$(DEPENDS): $(OBJ_DIR)%$(DEPEND_EXT): $(SRC_DIR)%$(CPPSRC_EXT) | $(OBJ_DIR) @echo -e &quot;\033[1;33m\nCompiling $&lt; ==&gt; $@ \033[0m...&quot; @$(CXX) -MM $(INC) -I$(INC_DIR) $(C_FLAGS) $&lt; &gt; $@.$$$$; \ sed &apos;s,\($*\)\.o[ :]*,$(OBJ_DIR)\1.o $@ : ,g&apos; &lt; $@.$$$$ &gt; $@; \ rm -f $@.$$$$;endifendif$(OBJECTS): $(OBJ_DIR)%$(OBJ_EXT): $(SRC_DIR)%$(CPPSRC_EXT) | $(OBJ_DIR) @echo -e &quot;\033[1;33m\nCompiling $&lt; ==&gt; $@ \033[0m...&quot; $(CXX) $(INC) -I$(INC_DIR) $(C_FLAGS) -c $&lt; -o $@ @echo &quot;&quot;$(PRE_PROCESS_OBJS): $(OBJ_DIR)%.i: $(SRC_DIR)%$(CPPSRC_EXT) | $(OBJ_DIR) @echo -e &quot;\033[1;33m\nPreprocessing $&lt; ==&gt; $@ \033[0m...&quot; $(CXX) $(INC) -I$(INC_DIR) $(C_FLAGS) -E $&lt; &gt; $@ @echo &quot;&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;clean&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;test&quot;$(OBJ_DIR): -mkdir $@endifendififneq &quot;$(LIB_TARGET)&quot; &quot;&quot;# $(LIB_TARGET): | $(LIB_DIR)$(LIB_TARGET):$(OBJECTS) $(DEPENDS) | $(LIB_DIR) @echo &quot;$(OBJECTS) ==&gt; $@&quot; $(AR) rc $(LIB_TARGET) $(OBJECTS) @echo &quot;&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;clean&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;test&quot;ifneq &quot;$(OBJ_DIR)&quot; &quot;$(LIB_DIR)&quot;$(LIB_DIR): -mkdir $@endifendifendifendif.ycm_extra_conf.py: makefile $(shell dirname $(PATH_MV_PRJ))/$(shell basename $(PATH_MV_PRJ))/tools/generate_ycm.sh $(DEPENDS) @echo -e &quot;\033[1;33m\ngenerate .ycm_extra_conf \033[0m...&quot; $(shell dirname $(PATH_MV_PRJ))/$(shell basename $(PATH_MV_PRJ))/tools/generate_ycm.sh &quot;$(INC)&quot; @echo &quot;&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;clean&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;test&quot;sinclude $(DEPENDS)endifendif 目录层级使用make -C来编译下一层目录, dir.mk。这里通过FILTER_OUT来排除要编译的目录。 123456789101112131415161718include $(shell dirname $(PATH_MV_PRJ))/$(shell basename $(PATH_MV_PRJ))/plib/makefile.plibFILTER_OUT+=$(wildcard makefile*) tagsifndef ALL_DIRS ALL_DIRS=$(filter-out $(FILTER_OUT), $(wildcard *))endif.PHONY: all clean $(ALL_DIRS)all: $(ALL_DIRS)clean: $(ALL_DIRS)$(ALL_DIRS): if [ -f $@/makefile ] ; \ then \ $(MAKE) -C $@ $(MAKECMDGOALS) ; \ fi 下面以我的工程中的comm_process目录来进行讲解一下普通目录的编译。目录树如下。 1234567~/m/a/s/comm_process(master) $ tree -L 1.|-- include|-- lib|-- makefile|-- obj`-- src makefile文件内容如下： 123456include $(shell dirname $(PATH_MV_PRJ))/$(shell basename $(PATH_MV_PRJ))/makeinclude/comm.mkINC+=-I./includeINC+=$(INC_MOBILE_TAIL_API) $(INC_SHARE_BUIS_COMM)LIB_TARGET=lib/libcommprocess.a 这个文件一开头就去include了我们之前的comm.mk文件，里面定义了各个编译.cpp，生成目标文件的规则。而INC变量，可以在comm.mk的OBJECT生成规则那里用到，用于提供给gcc -I进行查找头文件。而INC_MOBILE_TAIL_API， INC_SHARE_BUIS_COMM这些变量定义在我们之前说的那个makefle.plib下。一定定义成这样： 1INC_MOBILE_TAIL_API=-I../mobile_tail_api/include 下面介绍目录层级的makefile, 里面定义的规则是跳到下一级目录下去进行编译。以下的目录结构如下： 1234567891011121314~/m/a/share(master) $ tree -L 1.|-- busi_comm|-- comm_process|-- makefile|-- mt_spp|-- mysql|-- protocol|-- server_frame|-- task|-- task_frame`-- webapp_frame9 directories, 1 file makefile如下： 12FILTER_OUT+=mt_sppinclude $(shell dirname $(PATH_MV_PRJ))/$(shell basename $(PATH_MV_PRJ))/makeinclude/dir.mk 首先加入一些我们不希望编译的目录在FILTER_OUT里面。然后include我们第2点的dir.mk文件。然后在这层目录进行make，就会进行跳到各个目录去编译了。 到这里，会发现还不能达到我们项目的要求。我们项目一般是编出来一个动态库或者一个可执行文件。而我们上面编出来的只是静态库。我们可以根据在comm.mk的基础上去加规则来生成动态库或者可执行文件。以下以生成一个动态库为例子。 mtserver.mk 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859ifndef LIB_DIR LIB_DIR = bin/endififndef BIN_TARGET BIN_TARGET = $(LIB_DIR)lib$(TARGET_PREFIX)$(shell basename $(shell basename $(PWD)))$(TARGET_POSTFIX).soendifBIN_SO_NAME = $(word $(words $(subst /, ,$(BIN_TARGET))), $(subst /, ,$(BIN_TARGET)))BIN_LIB=$(shell dirname $(BIN_TARGET))LIB_TARGET=ALL+=$(BIN_TARGET)EXTRA+=$(BIN_TARGET)ifeq &quot;$(HAS_GIT)&quot; &quot;1&quot;ALL+=$(BIN_DIR).gitignoreendifinclude $(shell dirname $(PATH_MV_PRJ))/$(shell basename $(PATH_MV_PRJ))/makeinclude/comm.mkSO_DIR=$(PATH_PROJ_ROOT)/soSTRIP_SO_DIR=$(PATH_PROJ_ROOT)/strip_so$(BIN_TARGET): $(OBJECTS) $(DEPENDS) @echo -e &quot;\033[1;33m\nCompiling $&lt; ==&gt; $@ \033[0m...&quot; $(CXX) $(INC) $(C_FLAGS) -shared -Wl,-rpath,/usr/local/qzone/lib $(PATH_PROJ_ROOT)/application/share/server_frame/obj/service.o $(OBJECTS) $(LIB) -lz -o $@ ; \ $(PATH_PROJ_ROOT)/tools/check_symbol.sh $@; \ if [ $$? -eq 0 ]; then \ cp $@ $(SO_DIR) ;\ cp $@ $(STRIP_SO_DIR); \ strip $(STRIP_SO_DIR)/$(BIN_SO_NAME); \ fi;$(ALL) : del_target$(BIN_TARGET): | $(BIN_DIR)ifneq &quot;$(MAKECMDGOALS)&quot; &quot;clean&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;test&quot;$(BIN_DIR): -mkdir $@endifendififeq &quot;$(HAS_GIT)&quot; &quot;1&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;clean&quot;ifneq &quot;$(MAKECMDGOALS)&quot; &quot;test&quot;$(BIN_DIR).gitignore: | $(BIN_DIR) touch $@endifendifendif.PHONY:del_targetdel_target: $(RM) bin/* 这里我们一样include了comm.mk，然后在它的基础上去编译生成动态库。 到目前，我们的规则可以生成动态库了。但是还存在一个问题，就是同层目录，可能编译会有先后顺序的问题，比如，我要先编好share目录，才能去编业务的so目录。如以下的目录结构： 123456789~/m/application(master) $ tree -L 1.|-- makefile|-- server|-- share|-- tools`-- webapps4 directories, 1 file makefile如下： 123456~/m/application(master) $ cat makefileinclude $(shell dirname $(PATH_MV_PRJ))/$(shell basename $(PATH_MV_PRJ))/makeinclude/dir.mkWITHOUT_SHARE=$(filter-out share, $(ALL_DIRS))$(WITHOUT_SHARE): share 会发现，其实makefile跟其他跳去编下一层目录的makefile差不多，就是多了最后两行。倒数第二行，是将目录文件将share去掉，最后一行是将除了share目录的其他目录编译都需要先依赖share目录编译完才会去编译。 到这里我们的整个工程makefile都可以使用上面定义的comm.mk，dir.mk，mtserver.mk目录进行组织了。 总结一下改造的过程 编写comm.mk，dir.mk，放在工程比较顶层的目录中，以便其他目录去include。 编写特殊的makefile，如mtserver.mk文件，以便生成特殊上目标文件（如.so）去include。 从工程的根目录开始，如果当前目录下放的是一些子目录，则写一个makefile，去include dir.mk。如果当前目录下放的是src include obj lib的文件，里面分别放了.cpp .h文件，则去include comm.mk文件，如果当前目录下没有src include obj lib目录来组织.cpp .h文件，则将INC_DIR SRC_DIR OBJ_DIR LIB_DIR赋空，再去include comm.mk文件。]]></content>
      <categories>
        <category>工程管理</category>
      </categories>
      <tags>
        <tag>后台</tag>
        <tag>c</tag>
        <tag>c++</tag>
      </tags>
  </entry>
</search>
